# 使用标记接口来定义类型

标记接口是一个不包含方法声明的接口，它仅仅表示（或“标记”）实现这个接口的类具有某些属性。

比如说，考虑`Serializable`接口（第12章）。通过实现该接口，一个类就表示其实例可以写到`ObjectOutputStream`中（即『序列化』）。

你可能听说过，标记注解（条款39）使得标记接口失去了用武之地，不过这种说法是不对的。相比于标记注解来说，标记接口有两个优势。首先，**标记接口定义了一种类型，该类型由被标记的类的实例所实现；而标记注解是做不到这一点的**。标记接口类型的使用可以让你在编译期就捕获到错误，但是，如果使用标记注解，那这些错误直到运行期才能捕获到。

Java的序列化功能（第6章）使用`Serializable`标记接口来表示某个类型是可以序列化的。`ObjectOutputStream.writeObject`方法会序列化传递给它的对象，它要求参数是可以序列化的。如果该方法的参数类型是`Serializable`的，那么在编译期就可以检测到不恰当的对象序列化（通过类型检查）。编译期错误检测是标记接口的意图与目的，但遗憾的是，`ObjectOutputStream.write` API并未使用`Serializable`接口：其参数类型声明为`Object`，这样序列化一个不可序列化的对象的行为直到运行期才会出现失败。

相比于标记注解来说，标记接口的另外一个好处在于，其目标更为明确。如果某个注解类型声明为了`ElementType.TYPE`，那么它就可以应用到任何类或是接口上。假设你有一个标记，只能应用到某个特定接口的实现上。如果你将它定义成一个标记接口，那么你可以让它去继承它所适用的那个唯一的接口，以保证所有标记的类型也是它所适用的唯一接口的子类型。

可以说，`Set`接口就是这样一个受限制的标记接口。它只能应用于`Collection`子类型，不过除了`Collection`所定义的方法外，它并未添加任何新方法。一般来说，我们不将其看作是标记接口，因为它改变了`Collection`中几个方法的契约，比如说`add`、`equals`与`hashCode`。然而，我们可以很轻松地想出这样一个标记接口，它只能应用于某个特定接口的子类型，但又不会改变接口中任何方法的契约。这种标记接口可以描述整个对象的不变性，或是表示实例可以由其他类的方法进行处理（类似于`Serializable`接口表示实例可以由`ObjectOutputStream`进行处理一样）。

**与标记接口相比，标记注解的主要优势是成为更大的注解设施的一部分**。因此，在基于注解的框架中，标记注解会考虑到一致性。

那么，何时该使用标记注解，何时又该使用标记接口呢？显然，如果标记使用在类或是接口外的其他程序元素上，那就必须得用注解了，因为只有类和接口才能实现或是继承一个接口。如果标记只使用在类和接口上，那你就要自己想想了：『我所编写的方法是不是只接受拥有这个标记的对象呢』？如果是这样，那就应该选择标记接口而非注解。因为这样可以将接口作为方法的参数类型，能充分利用上编译期类型检查的好处。如果你确定方法永远都不会只接收带有标记的对象，那最好就使用标记注解。此外，如果标记是大量使用了注解的框架的一部分，那么标记注解就是个更好的选择。

总之，标记接口和标记注解都有它们的用处。如果需要定义的类型中并没有任何新的方法，那么标记接口就是一个好的选择。如果想要标记类与接口之外的程序元素，或是使得标记适合于已经大量使用了注解类型的框架，那么标记注解就是不二之选。**如果编写的标记注解类型的目标是ElementType.TYPE，那就要好好想想到底该使用注解类型还是标记接口**。

从某种意义上来说，本条款与条款22相反，条款22是这么说的：『如果不想定义类型，那就不要使用接口』。本条款则是这样说的：『如果想要定义类型，请使用接口』。