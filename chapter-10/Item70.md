# 可恢复条件下使用受检异常，程序错误下使用运行时异常

`Java`提供了3种异常：受检异常，运行期异常以及错误。程序员们常常搞不清楚何时应该使⽤哪⼀种异常类型。虽然对异常的选择并不总是清晰可见的，不过还是存在⼀些通⽤的原则，这些原则提供了较强的指导意义。

决定使⽤受检异常还是⾮受检异常的基本原则是：对于那些调⽤者可以从中恢复过来的情况来说，请使⽤受检异常。通过抛出受检异常，你会强制调⽤者在`catch`块中处理异常，或是将其再次抛出来。对于⽅法声明所抛出的每个受检异常来说，它都是对`API`⽤户的⼀种强有⼒的暗示，告诉⽤户相关的情况是调⽤该⽅法的⼀种可能的结果。

通过让⽤户⾯对受检异常，`API`设计者就表明可以从异常情况中恢复过来。⽤户可以通过捕获并忽略掉异常来忽视`API`设计者的意图，不过这么做通常是不好的（条款77）。

有两种非受检异常：运⾏期异常与错误。他们在⾏为上是⼀致的：都是不需要，通常也不应 该被捕获的异常。如果程序抛出了非受检异常或是错误，那么通常都表示⽆法恢复，再继续执⾏的话情况将会变得越来越糟糕。如果程序没有捕获这种异常，那就会导致当前线程停⽌， 同时给出⼀条恰当的错误消息。

**请使⽤运⾏期异常来标识程序的错误**。⼤多数运⾏期异常都表示违背了先决条件。先决条件的违背表示`API`的客户端没有遵守`API`规范所设⽴的契约。⽐如说，数组访问的契约指明了数组索引必须要介于0到数组⻓度减1（包含）之间。`ArrayIndexOutOfBoundsException`就表示违背了这种先决条件。

该建议的⼀个问题在于，你正在处理的到底是⼀种可恢复的情况还是⼀种程序错误并不总是那么清楚的。⽐如说，考虑资源耗尽这种情况，它可能是由诸如分配了不合理、过⼤的数组这样的程序错误所导致，也有可能是由资源确实短缺所造成。如果资源耗尽是由资源临时短缺或是临时过⾼的资源需求所造成，那么这种情况就是可恢复的。`API`设计者需要判断某种资源耗尽情况是否要考虑到恢复。如果你相信某种情况考虑到了恢复，那就请使⽤受检异常； 如果不相信，那就请使⽤运⾏期异常。如果不确定是否可以恢复，那就最好使⽤非受检异常， 条款71对其中的原因进⾏了讨论。

虽然`Java`语言规范并不要求这样做，但是有一个严格的约定，即`JVM`保留`error`以表示资源不足、不变故障或其他使其无法继续执行的条件。鉴于这种约定几乎被普遍接受，最好不要实现任何新的`Error`子类。因此，你实现的所有非受检异常都应该（直接或间接）继承`RuntimeException`。不仅不应该定义`Error`子类，而且除了`AssertionError`之外，也不应该抛出它们。可以定义一个`throwable`，它不是`Exception`、`RuntimeException`或`Error`的子类。`Java`语言规范无法直接处理`throwable`，但可以隐式地指定它们的行为跟普通的受检异常一样。那么，什么时候应该使用这种野路子呢？一句话，永远不会。它们与普通的受检异常相比没有什么好处，只会使`API`的用户感到困惑。

`API`设计人员经常忘记，异常是可以定义在任意方法的成熟对象。这类方法的主要用途是捕获异常，并带着额外的有关导致异常出现的条件相关信息。如果没有这样的方法，程序员就会解析异常的字符串表示，以找出额外的信息。这是非常糟糕的做法（条款12）。`Throwable`类很少指定其字符串表示的细节，因此字符串表示可能因实现和版本而异。因此，解析异常的字符串表示的代码很可能是不可靠的和脆弱的。

由于受检异常通常表示可恢复条件，因此特别重要的是它们提供提供信息的方法来帮助调用者从异常条件中恢复。比如，假如当使用礼品卡购物时，因为余额不足导致失败。这时候，会抛出一个受检异常。这个异常应该提供一个访问方法来查询还差多少金额。这样调用者就能将信息传达给购物者。关于这个主题的更多信息可以看条款75。

总而言之，希望程序恢复的抛出受检异常，对于编程错误抛出非受检异常。当有疑问时，就抛出非受检异常。不要定义任何既不是受检异常也不是运行时异常的`thrownable`对象。为受检异常提供方法以帮助进行恢复。