# 可恢复条件下使用受检异常，程序错误下使用运行时异常

`Java`提供3中可抛出的异常情况：受检异常，运行时异常以及错误。程序员常常感到困惑，这些异常分别在什么时候使用是恰当的。虽然结果并不总是清晰的，但是有一些通用的规则可以提供强有力的指导。

决定使用受检异常还是非受检异常的主要规则是：当希望调用者能在异常条件下合理地恢复时，使用受检异常。通过抛出一个受检异常，可以强制调用方在`catch`子句中处理异常，或者将异常向上抛出。因此，每一个方法声明抛出的受检异常都是对`API`使用者的有效的提示，关联条件可能是调用方法的结果。

通过将受检异常抛给使用者，`API`设计者的意图是从异常条件中得到恢复。用户可以通过捕捉异常并忽略它来忽略命令，但这通常不是一个好主意（条款77）。

有2个非受检异常：运行时异常和错误。它们的行为是一样的：都是不需要的异常，且通常不应该被捕获。如果一个程序抛出一个非受检异常或者一个错误，那么一般来说，恢复是不可能的，并且继续执行弊大于利。如果一个程序没有捕获这个异常，它会导致当前这个线程停止，并带有恰当的错误信息。

**用运行时异常表示程序错误**。运行时异常的绝大多数表示先决条件冲突。违反先决条件就是使用`API`的客户未能遵守`API`规范描述的约定。比如，对于数组访问的约定就是访问数组的索引必须位于0到数组长度减1之间（开区间）。`ArrayIndexOutOfBoundsException `就表示违反了这个前提条件。

这条建议的问题是，并没说清楚你是处理可恢复的条件还是程序错误。比如，考虑资源耗尽的情况，这可能是由编程错误（比如分配了一个不合理的大数组）或资源真正短缺造成的。如果资源耗尽是由暂时的短缺或暂时增加的需求造成的，这种情况很可能是可恢复的。一个给定的资源耗尽实例是否允许恢复是由`API`设计人员判断的问题。如果你认为某种情况可能允许恢复，请使用受检异常；否则，使用运行时异常。如果不清楚是否可以恢复，你最好使用非受检异常，这在条款71中会说明理由。

虽然`Java`语言规范并不要求这样做，但是有一个严格的约定，即`JVM`保留`error`以表示资源不足、不变故障或其他使其无法继续执行的条件。鉴于这种约定几乎被普遍接受，最好不要实现任何新的`Error`子类。因此，你实现的所有非受检异常都应该（直接或间接）继承`RuntimeException`。不仅不应该定义`Error`子类，而且除了`AssertionError`之外，也不应该抛出它们。可以定义一个`throwable`，它不是`Exception`、`RuntimeException`或`Error`的子类。`Java`语言规范无法直接处理`throwable`，但可以隐式地指定它们的行为跟普通的受检异常一样。那么，什么时候应该使用这种野路子呢？一句话，永远不会。它们与普通的受检异常相比没有什么好处，只会使`API`的用户感到困惑。

`API`设计人员经常忘记，异常是可以定义在任意方法的成熟对象。这类方法的主要用途是捕获异常，并带着额外的有关导致异常出现的条件相关信息。如果没有这样的方法，程序员就会解析异常的字符串表示，以找出额外的信息。这是非常糟糕的做法（条款12）。`Throwable`类很少指定其字符串表示的细节，因此字符串表示可能因实现和版本而异。因此，解析异常的字符串表示的代码很可能是不可靠的和脆弱的。

由于受检异常通常表示可恢复条件，因此特别重要的是它们提供提供信息的方法来帮助调用者从异常条件中恢复。比如，假如当使用礼品卡购物时，因为余额不足导致失败。这时候，会抛出一个受检异常。这个异常应该提供一个访问方法来查询还差多少金额。这样调用者就能将信息传达给购物者。关于这个主题的更多信息可以看条款75。

总而言之，希望程序恢复的抛出受检异常，对于编程错误抛出非受检异常。当有疑问时，就抛出非受检异常。不要定义任何既不是受检异常也不是运行时异常的`thrownable`对象。为受检异常提供方法以帮助进行恢复。