# 可恢复条件下使用受检异常，程序错误下使用运行时异常

`Java`提供3中可抛出的异常情况：受检异常，运行时异常以及错误。程序员常常感到困惑，这些异常分别在什么时候使用是恰当的。虽然结果并不总是清晰的，但是有一些通用的规则可以提供强有力的指导。

决定使用受检异常还是非受检异常的主要规则是：当希望调用者能在异常条件下合理地恢复时，使用受检异常。通过抛出一个受检异常，可以强制调用方在`catch`子句中处理异常，或者将异常向上抛出。因此，每一个方法声明抛出的受检异常都是对`API`使用者的有效的提示，关联条件可能是调用方法的结果。

通过将受检异常抛给使用者，`API`设计者的意图是从异常条件中得到恢复。用户可以通过捕捉异常并忽略它来忽略命令，但这通常不是一个好主意（条款77）。

有2个非受检异常：运行时异常和错误。它们的行为是一样的：都是不需要的异常，且通常不应该被捕获。如果一个程序抛出一个非受检异常或者一个错误，那么一般来说，恢复是不可能的，并且继续执行弊大于利。如果一个程序没有捕获这个异常，它会导致当前这个线程停止，并带有恰当的错误信息。

**用运行时异常表示程序错误**。运行时异常的绝大多数表示先决条件冲突。违反先决条件就是使用`API`的客户未能遵守`API`规范描述的约定。比如，对于数组访问的约定就是访问数组的索引必须位于0到数组长度减1之间（开区间）。`ArrayIndexOutOfBoundsException `就表示违反了这个前提条件。

这条建议的问题是，并没说清楚你是处理可恢复的条件还是程序错误。比如，考虑资源耗尽的情况，这可能是由编程错误（比如分配了一个不合理的大数组）或资源真正短缺造成的。如果资源耗尽是由暂时的短缺或暂时增加的需求造成的，这种情况很可能是可恢复的。一个给定的资源耗尽实例是否允许恢复是由`API`设计人员判断的问题。如果你认为某种情况可能允许恢复，请使用受检异常；否则，使用运行时异常。如果不清楚是否可以恢复，你最好使用非受检异常，这在条款71中会说明理由。

通过将抛出异常的方法分解为两个方法，还可以将受检异常转换为非受检异常，第一个方法返回一个布尔值，指示是否将抛出异常。这个`API`重构将调用序列转换为：

```java
// Invocation with checked exception
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // Handle exceptional condition
}
```

变为：

```java
// Invocation with state-testing method and unchecked exception
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... // Handle exceptional condition
}
```

