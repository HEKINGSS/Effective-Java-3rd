# 可恢复条件下使用受检异常，程序错误下使用运行时异常

`Java`提供了3种异常：受检异常，运行期异常以及错误。程序员们常常搞不清楚何时应该使⽤哪⼀种异常类型。虽然对异常的选择并不总是清晰可见的，不过还是存在⼀些通⽤的原则，这些原则提供了较强的指导意义。

决定使⽤受检异常还是⾮受检异常的基本原则是：对于那些调⽤者可以从中恢复过来的情况来说，请使⽤受检异常。通过抛出受检异常，你会强制调⽤者在`catch`块中处理异常，或是将其再次抛出来。对于⽅法声明所抛出的每个受检异常来说，它都是对`API`⽤户的⼀种强有⼒的暗示，告诉⽤户相关的情况是调⽤该⽅法的⼀种可能的结果。

通过让⽤户⾯对受检异常，`API`设计者就表明可以从异常情况中恢复过来。⽤户可以通过捕获并忽略掉异常来忽视`API`设计者的意图，不过这么做通常是不好的（条款77）。

有两种非受检异常：运⾏期异常与错误。他们在⾏为上是⼀致的：都是不需要，通常也不应该被捕获的异常。如果程序抛出了非受检异常或是错误，那么通常都表示⽆法恢复，再继续执⾏的话情况将会变得越来越糟糕。如果程序没有捕获这种异常，那就会导致当前线程停⽌， 同时给出⼀条恰当的错误消息。

**请使⽤运⾏期异常来标识程序的错误**。⼤多数运⾏期异常都表示违背了先决条件。先决条件的违背表示`API`的客户端没有遵守`API`规范所设⽴的契约。⽐如说，数组访问的契约指明了数组索引必须要介于0到数组⻓度减1（包含）之间。`ArrayIndexOutOfBoundsException`就表示违背了这种先决条件。

该建议的⼀个问题在于，你正在处理的到底是⼀种可恢复的情况还是⼀种程序错误并不总是那么清楚的。⽐如说，考虑资源耗尽这种情况，它可能是由诸如分配了不合理、过⼤的数组这样的程序错误所导致，也有可能是由资源确实短缺所造成。如果资源耗尽是由资源临时短缺或是临时过⾼的资源需求所造成，那么这种情况就是可恢复的。`API`设计者需要判断某种资源耗尽情况是否要考虑到恢复。如果你相信某种情况考虑到了恢复，那就请使⽤受检异常； 如果不相信，那就请使⽤运⾏期异常。如果不确定是否可以恢复，那就最好使⽤非受检异常， 条款71对其中的原因进⾏了讨论。

虽然`Java`语言规范并没有这么要求过，不过惯常的约定是错误是留给`JVM`所用的，用于标识资源不足、不可改变的失败，或是其他导致执行无法继续下去的情况。几乎所有人都接受了这种约定，我们最好不要实现任何新的`Error`子类。因此，你所实现的所有非受检异常都应 该继承自`RuntimeException`（直接或是间接）。不仅不应该定义`Error`的子类，而且除了` AssertionError`外，你也不应该抛出他们。

可以定义一个并非`Exception`、`RuntimeException`或是`Error`子类的异常。`Java`语言规范并未直接指出这种异常，不过规范却隐式地表明他们的行为与普通的受检异常是一样的（是`Exception`而非`RuntimeException`的子类)。那么何时应该使用这种异常呢？一句话，永远都不要用。相⽐于普通的受检异常来说，他们没有提供任何好处，只会让`API`用户感到困`惑。

`API`设计者们常常会忘记异常也是功能完全的对象，可以在上⾯定义任何⽅法。这种方法的主要作⽤是提供捕获异常的代码，同时给出与导致异常抛出的情况相关的额外信息。如果缺少这类方法，那么程序员们就只能解析异常的字符串表示来找出额外的信息了。这是个非常 不好的实践（条款12）。异常类很少会指定其字符串表示的细节信息，因此字符串表示在不同的实现以及不同的发布间是有区别的。因此，解析异常的字符串表示的代码很可能是⽆法移植且脆弱的。

由于检查异常通常标识可恢复的情况，因此对于他们来说，提供⼀些方法来装配信息以帮助调用者从异常情况中恢复过来是⾮常重要的事情。⽐如说，假设使⽤礼品卡购物，由于⾦额不⾜导致失败，这会抛出⼀个受检异常。该异常应该提供一个访问器方法来查询缺少的金额。 这样调用者就可以将⾦额告诉给顾客了。参见条款75来了解关于该主题的更多信息。

总结一下，对于可恢复的情况请抛出受检异常，对于程序错误请抛出非受检异常。如果存疑， 那就请抛出非受检异常。不要定义任何既不是受检异常，也不是运行期异常的异常。在受检异常中请提供⼀些⽅法来帮助恢复。