# 努力保持失败的原子性

在对象抛出异常后，通常我们期望对象依旧处于⼀种定义良好、可⽤的状态之下，即便失败发⽣在执⾏某个操作的过程中亦如此。对于受检异常来说更是如此，因为我们希望调用者从这些异常中恢复。⼀般来说，失败的⽅法调⽤应该将对象置于调⽤前的状态。具有这个属性的⽅法就是所谓的失败原⼦性的。

有⼏种⽅式可以实现这个效果。最简单的一种就是设计不可变对象（条款17）。如果对象是不可变的，那么天然就支持失败原子性。如果操作失败，那么它就会防⽌新对象的创建，但是它永远不会将既有对象置于⼀种不⼀致的状态下，因为在创建后，每个对象的状态是⼀致的，⽆法在随后进⾏修改。

对于操作可变对象的方法，实现失败原子性的最常见方法是在执行操作之前检查参数的有效性（条款49）。这会使得对象修改开始前⼤多数异常都会抛出来。例如，条款7里的`Stack`的`pop` 方法：

```java
public Object pop() {
	if (size == 0)
		throw new EmptyStackException();
  
	Object result = elements[--size];
	elements[size] = null; 		// Eliminate obsolete reference
	return result;
}
```

如果去掉初始⼤⼩的检查，那么当该⽅法尝试从空的栈中弹出元素时就会抛出异常。这会导致`size`字段处于⼀种不⼀致（负数）的状态下，这样后续对该对象的任何⽅法调⽤都会失败。而且，`pop`方法会抛出`ArrayIndexOutOfBoundsException`异常，这也是不恰当的，这与条款73的主题相悖。

与实现失败原⼦性密切相关的⼀种⽅式是对计算进⾏排序，使得可能失败的任何部分都位于修改对象之前。在不执⾏部分计算就⽆法检查参数时，这种⽅式是之前⽅式的⼀种⾃然扩 展。例如说`TreeMap`，其元素会根据某种排序规则进⾏排序。若想向`TreeMap`中添加元素，该元素类型必须要能通过`TreeMap`的排序规则进⾏⽐较。添加类型不正确的元素会导 致`ClassCastException`异常，这是在`TreeMap`中搜索元素时所导致的，⽽该异常会在修改`TreeMap`前就抛出。

实现失败原⼦性的第3种⽅式是在对象的临时副本中执⾏操作，当操作完成后使⽤临时副本来替换掉对象的内容。当数据被存储到临时数据结构中时，如果计算可以更加快速的完成， 那么这种⽅式就是⾃然⽽然的了。⽐如说，某个排序函数会在排序前将其输⼊列表复制到⼀个数组中以降低内部排序循环中访问元素的成本。这么做是为了性能，不过作为额外的好处，还可以确保当排序失败时，输⼊列表不会受到影响。

实现失败原⼦性的最后⼀种，也是不常使⽤的⼀种⽅式是编写恢复代码，并使⽤它来拦截操 作过程中所出现的失败，这会使得对象能够回滚到操作开始前的状态。这种⽅式主要⽤于持久化（基于磁盘）的数据结构。

虽然⼀般来说，失败原⼦性是我们所期待的，不过我们并⾮总能做到这⼀点。⽐如说，如果两个线程在没有进⾏恰当同步的情况下尝试并发修改同⼀个对象，那么该对象就可能会处于⼀种不⼀致的状态之下。因此，在出现`ConcurrentModificationException`异常后，我们就不能认为对象还可以继续使⽤了。`Error`是不可恢复的，因此在抛出`AssertionError`时，无需保证失败原子性。

即便可以实现失败原⼦性，我们也并⾮总是需要它。对于某些操作来说，它将极大增加成本或复杂性。也就是说，当你意识到问题时，实现失败原⼦性通常应该是件很容易的事 情

总结⼀下，作为原则，属于⽅法规范⼀部分的任何⽣成的异常都应该将对象置于⽅法调⽤前的状态之下。当违背了这条原则时，`API`⽂档应该清晰表述出对象会处于何种状态下。但遗憾的是，⼤部分`API`⽂档都没有做到这⼀点。

