# 避免受检异常的不必要使用

很多`Java`程序员不喜欢受检异常，不过如果使用得当，它们是可以改进`API`和程序的。与返回码和非受检异常不同，受检异常会强迫程序员处理问题，这增强了程序的可靠性。即便如此，在`API`中过度使用受检异常会使得它们变得讨厌。如果一个方法抛出受检异常，那么调用该方法的代码必须在一个或多个`catch`块中对其进行处理，或者将其抛出，让其向外传播。无论哪种方式，都会加重`API`用户的负担。这种负担在`Java8`中更加严重了，因为抛出受检异常的方法是无法在`Stream`中直接使用的（条款45-48）。

如果无法通过合理使用`API`来防止异常情况，同时使用`API`的程序员在面对异常时可以采取一些行之有效的措施，那么这种负担就是合情合理的了。除非这两个条件都满足，否则使用非受检异常才是合理的。问问自己，程序员会如何处理异常。这是最好的做法吗？

```java
} catch (TheCheckedException e) {
	throw new AssertionError(); // Can't happen!
}
```

或者是这样？

```java
} catch (TheCheckedException e) {
	e.printStackTrace(); // Oh well, we lose.
	System.exit(1);
}
```

如果程序员也没什么好的办法，那么未检查异常就是我们所需要的了。

如果是由一个放法所抛出的单个受检异常，那么就会对程序员造成更为严重的负担。如果还有其他受检异常，那么方法就需要位于`try`块中，同时该异常还需要另外的`catch`块。如果方法抛出单个受检异常，那么该异常就是唯⼀的原因，方法就得位于`try`块中，同时无法直接⽤在`Stream`中。在这些情况下，你需要问问自己，是否有其他方式可以避免使用受检异常。

消除受异常最简单的方式是返回所需要结果类型的⼀个`Optional`（条款55）。相比于抛出受检异常，方法这时只需要返回⼀个空的`Optional`即可。这种方式的缺点在于方法无法返回关于其无法执⾏所要求的计算的任何额外信息。与之相反，异常拥有描述性的类型，可以通过⽅法来提供额外的信息（条款70）。

还可以通过将抛出异常的方法分解为两个方法来将受检异常转换为非受检异常，第一个方法返回一个`boolean`值，标识是否会抛出异常。这种`API`重构将如下调⽤用序列：

```java
// Invocation with checked exception
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // Handle exceptional condition
}
```

转换为：

```java
// Invocation with state-testing method and unchecked exception
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... // Handle exceptional condition
}
```

这种重构并不总是恰当的，不过如果使用得当，它会使得`API`更加易用。虽然后者的调⽤序列不如前者那么简洁，但重构后的`API`变得更加灵活了。如果程序员知道调用会成功，或是如果调用失败会让线程终止，那么重构还可以支持如下调⽤序列：

```java
obj.action(args);
```

如果你认为上述这种调⽤序列是可行的，那么`API`重构就是恰当的。得到的API本质上就是条款69所介绍的状态测试⽅法`API`，它也要注意这⼀点：如果在没有外部同步的情况下并发访问某个对象，或是遇到了外部带来的状态转换，那么这种重构就是不恰当的，因为对象的状态有可能会在`actionPermitted`与`action`调用间发生改变。如果一个单独的`actionPermitted`⽅法重复了`action`方法的工作，那么出于性能考量，我们就不应该进行重构了。

总结一下，如果谨慎使用，那么检查异常会增加程序的可靠性；如果过度使用，那么他们会使得`API`用起来变得痛苦不堪。如果调⽤者⽆无法从失败中恢复过来，那就请抛出非受检异常。如果可以恢复，并且你想要强制调⽤者处理异常情况，那么首先请考虑返回一个 `optional`。只有在这种方式⽆法在失败的情况下提供充足的信息时才应考虑使用受检异常。