# 避免受检异常的不必要使用

很多`Java`程序员不喜欢受检异常，不过如果使用得当，它们是可以改进`API`和程序的。与返回码和非受检异常不同，受检异常会强迫程序员处理问题，这增强了程序的可靠性。即便如此，在`API`中过度使用受检异常会使得它们变得讨厌。如果一个方法抛出受检异常，那么调用该方法的代码必须在一个或多个`catch`块中对其进行处理，或者将其抛出，让其向外传播。无论哪种方式，都会加重`API`用户的负担。这种负担在`Java8`中更加严重了，因为抛出受检异常的方法是无法在`Stream`中直接使用的（条款45-48）。

如果无法通过合理使用`API`来防止异常情况，同时使用`API`的程序员在面对异常时可以采取一些行之有效的措施，那么这种负担就是合情合理的了。除非这两个条件都满足，否则使用非受检异常才是合理的。问问自己，程序员会如何处理异常。这是最好的做法吗？

```java
} catch (TheCheckedException e) {
	throw new AssertionError(); // Can't happen!
}
```

或者是这样？

```java
} catch (TheCheckedException e) {
	e.printStackTrace(); // Oh well, we lose.
	System.exit(1);
}
```

如果程序员也没什么好的办法，那么未检查异常就是我们所需要的了。

如果是由一个放法所抛出的单个受检异常，那么就会对程序员造成更为严重的负担。如果还有其他受检异常，那么方法就需要位于`try`块中，同时该异常还需要另外的`catch`块。如果方法抛出单个受检异常，那么该异常就是唯⼀的原因，方法就得位于`try`块中，同时无法直接⽤在`Stream`中。在这些情况下，你需要问问自己，是否有其他方式可以避免使用受检异常。

消除受异常最简单的方式是返回所需要结果类型的⼀个`Optional`（条款55）。相比于抛出受检异常，方法这时只需要返回⼀个空的`Optional`即可。这种方式的缺点在于方法无法返回关于其无法执⾏所要求的计算的任何额外信息。与之相反，异常拥有描述性的类型，可以通过⽅法来提供额外的信息（条款70）。

通过将抛出异常的方法分解为两个方法，还可以将受检异常转换为非受检异常，第一个方法返回一个布尔值，指示是否抛出异常。重构后的`API`将下面这个调用顺序：

```java
// Invocation with checked exception
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // Handle exceptional condition
}
```

变成了如下：

```java
// Invocation with state-testing method and unchecked exception
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... // Handle exceptional condition
}
```

这种重构并不总是恰当的。但是在合适的地方，他可以使`API`用起来更加舒适。尽管第二种调用顺序并不比第一个优雅，但重构后的`API`更具有灵活性。如果程序员知道调用将成功，或者在调用失败时，满足于让线程终止。重构也允许这个直接的调用顺序：

```java
obj.action(args);
```

如果你认为这个直接的调用顺序将是规范，那么`API`重构可能是合适的。最后的`API`本质上就是条款69里的状态测试方法`API`，并且有着相同的警告：如果一个对象被并发的访问且没有外部同步或受外部诱导状态转换，这种重构就是不恰当的。因为对象的状态可能会发生改变在`actionPermitted`和`action`方法调用之间。如果一个单独的`actionPermitted`方法会重复`action`方法的工作，那么出于性能原因，该重构可能会被禁止。

总之，有节制地使用受检异常，可以提高程序的可靠性；过度使用时，它们会使`API`使用起来很痛苦。如果调用方无法从失败中恢复，则抛出非受检异常。如果可以恢复，并且你希望强制调用者处理异常条件，那么优先考虑返回一个`optional`。只有在失败的情况下需要提供额外的信息时，才应该抛出受检异常。