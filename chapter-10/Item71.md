# 避免受检异常的不必要使用

许多`Java`程序员不喜欢受检异常，但如果恰当使用，它们可以改进`API`和程序。与返回代码和非受检异常不同，受检异常迫使程序员处理问题，提高了可靠性。也就是说，在`API`中过度使用受检异常会使`API`使用起来非常不舒服。如果一个方法抛出受检异常，那么调用该方法的代码必须在一个或多个`catch`块中处理这些异常，或者声明它抛出这些异常并让它们向外传播。无论哪种方式，都会给`API`的用户带来负担。`Java 8`中这个负担加重了，因为抛出受检异常的方法不能直接在`Stream`中使用（条款45-48）。

如果正确地使用`API`也可能发生异常情况，并且使用`API`的程序员在遇到异常时可以采取一些有用的操作，那么这种负担可能是合理的。除非这两个条件都满足，否则非受检异常才是合适的。作为试金石，问问你自己程序员将如何处理异常。这是我们能做到的最好的结果吗？

```java
} catch (TheCheckedException e) {
	throw new AssertionError(); // Can't happen!
}
```

或者这样子？

```java
} catch (TheCheckedException e) {
	e.printStackTrace(); // Oh well, we lose.
	System.exit(1);
}
```

如果程序员无法很好地去判断这些，那么就使用非受检异常。

如果受检异常是方法抛出的唯一异常，则由受检异常给程序员造成的额外负担将大大增加。如果还有其他异常，则该方法必须已经出现在`try`块中，而这个异常最多需要另一个`catch`块。如果一个方法抛出单个受检异常，此异常是该方法必须出现在`try`块中而不能直接在`stream`中使用的唯一原因。在这种情况下，最好问问自己是否有办法避免这个受检异常。

消除一个受检异常的最容易的方法是返回期望的结果类型的`optional`。除了抛出一个受检异常外，方法还可以简单地返回一个空的`optional`。这种技术的缺点是，该方法不能返回任何说明其无法执行所需计算的额外信息。但是，异常拥有有描述性的类型，还通过方法提供了额外的信息（条款70）。

通过将抛出异常的方法分解为两个方法，还可以将受检异常转换为非受检异常，第一个方法返回一个布尔值，指示是否抛出异常。重构后的`API`将下面这个调用顺序：

```java
// Invocation with checked exception
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // Handle exceptional condition
}
```

变成了如下：

```java
// Invocation with state-testing method and unchecked exception
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... // Handle exceptional condition
}
```

这种重构并不总是恰当的。但是在合适的地方，他可以使`API`用起来更加舒适。尽管第二种调用顺序并不比第一个优雅，但重构后的`API`更具有灵活性。如果程序员知道调用将成功，或者在调用失败时，满足于让线程终止。重构也允许这个直接的调用顺序：

```java
obj.action(args);
```

如果你认为这个直接的调用顺序将是规范，那么`API`重构可能是合适的。最后的`API`本质上就是条款69里的状态测试方法`API`，并且有着相同的警告：如果一个对象被并发的访问且没有外部同步或受外部诱导状态转换，这种重构就是不恰当的。因为对象的状态可能会发生改变在`actionPermitted`和`action`方法调用之间。如果一个单独的`actionPermitted`方法会重复`action`方法的工作，那么出于性能原因，该重构可能会被禁止。

总之，有节制地使用受检异常，可以提高程序的可靠性；过度使用时，它们会使`API`使用起来很痛苦。如果调用方无法从失败中恢复，则抛出非受检异常。如果可以恢复，并且你希望强制调用者处理异常条件，那么优先考虑返回一个`optional`。只有在失败的情况下需要提供额外的信息时，才应该抛出受检异常。