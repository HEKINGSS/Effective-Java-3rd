# 只在异常条件下使用异常

如果运气不好，你可能会遇到像下面这样的代码：

```java
// Horrible abuse of exceptions. Don't ever do this!
try {
	int i = 0;
	while(true)
		range[i++].climb();

} catch (ArrayIndexOutOfBoundsException e) {

}
```
上述代码做了什么事情呢？从代码中是很难看出来的，单凭这一点，我们就不要这么写代码 （条款67）。这是循环遍历数组中元素的一种非常不好的做法。当这个⽆限循环尝试访问数组边界外的第⼀个元素时，它就会终止，终止的方式则是抛出、捕获并忽略掉` ArrayIndexOutOfBoundsException`。它等价于如下循环遍历数组的标准做法，这种做法对 于任何一个Java程序员来说都是耳熟能详的：

```java
for (Mountain m : range)
	m.climb();
```
那为何还有⼈会选择使⽤基于异常的循环⽅式而非标准方式呢？主要是存在一些误导，那就是使用基于异常的方式可以改进性能，因为`JVM`会检查所有数组访问的边界，⽽正常的循环终⽌测试（被编译期隐藏掉了，不过依旧存在于`for-each`循环中）是冗长且应该避免的。这种说法主要存在3个错误：

 - 由于异常的设计目的是针对于异常情况的，因此`JVM`的实现者们并没有多少动力使其像显式测试那般快。

 - 将代码放到`try-catch`块中会压制`JVM`实现可能会执行的⼀些优化。

 - 循环数组的标准⽅式并不一定会导致冗余的检查。很多`JVM`实现都会对其进⾏优化。 

实际上，基于异常的处理方式要比标准方式慢很多。在我的机器上，对于包含了100个元素的数组来说，前者遍历的速度要比后者慢差不多两倍。

基于异常的循环不仅会让代码的⽬的变得模糊并降低性能，⽽且还⽆法保证代码可以正常使用。如果循环中有`Bug`，那么流程控制中对于异常的使⽤就会掩盖掉`Bug`，这会导致调试过程变得更加困难。 假设循环体中的计算调⽤了⼀个⽅法，该⽅法对某个不相关的数组执⾏了越界访问。如果使⽤了合理的循环⽅式，那么`Bug`就会⽣成一个未捕获的异常，这会导致线程⽴刻终止，并打印出完整的堆栈信息。 如果误⽤了基于异常的循环，那就会捕获到与`Bug `相关的异常，并将其错误地解释为正常的循环终⽌。 

这个故事的寓意很简单：**⻅名知意，异常只⽤于异常情况；我们永远都不应该将其⽤在正常的流程控制中**。更为⼀般地，要优先选择标准、易读的写法，⽽⾮声称可以提供更好性能的所谓更加聪明的技术。即便性能优势确实存在，但它在不断改进的平台实现⾯前可能也不复存在了。不过，源⾃那些耍⼩聪明的技术的不易察觉的`Bug`以及维护梦魇却是实实在在存在的。

该原则对于`API`设计也是适⽤的。**设计良好的API绝不会强制其客户端对普通的流程控制使⽤异常**。如果⼀个类中有个『状态依赖』⽅法，它只能在某些不可预测的情况下调⽤，那么它通常也要有个单独的『状态测试』⽅法，表示调⽤这个『状态依赖』⽅法是否是恰当的。⽐如说，` Iterator`接⼝就有个状态依赖⽅法`next`以及相应的状态测试⽅法`hasNext`。这使得通过传统的`for`循环来以标准的⽅式迭代集合成为了可能（以及`for-each`循环，其中`hasNext`在内部得到了使⽤）：

```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
	...
}
```

如果`Iterator`缺少`hasNext`⽅法，那么客户端就不得不这么做了：

```java
// Do not use this hideous code for iteration over a collection!
try {
	Iterator<Foo> i = collection.iterator();
	while(true) {
	Foo foo = i.next();
	...
	}
} catch (NoSuchElementException e) {
    
}
```

看过了本条款⼀开始所介绍的那个数组迭代示例后，对于上述代码应该会很熟悉了。除了冗⻓和容易产⽣误导外，基于异常的循环的性能也很差，⽽且还会掩盖掉系统中其他不相关部分所产⽣的`Bug`。

相⽐于提供单独的状态测试⽅法来说，另外⼀种替代⽅案是在⽆法执⾏所需的计算时，让状态依赖⽅法返回⼀个空的`optional`（条款55）或是⼀个特别的值，如`null`。

下⾯给出⼀些关于如何在状态测试⽅法与`optional`或是特别的返回值之间进⾏选择的建议。

如果对象会被并发访问，并且没有外部的同步措施，或是会受到外部施加的状态转换，那就需要使⽤`optional`或是特别的返回值，因为对象的状态有可能会在状态测试⽅法与状态依赖⽅法调⽤之间发⽣变化。如果单独的状态测试⽅法需要重复状态依赖⽅法的⼯作，那么出于性能的考量，我们需要使⽤`optional`或是特别的返回值。其他就没有什么区别了，状态测试⽅法要稍好于特殊的返回值。它的可读性会稍好⼀些，即便使⽤不当也更容易发现：如果忘记调⽤了状态测试⽅法，那么状态依赖⽅法就会抛出异常，这使得`Bug`⽆处遁形；如果忘记检查特殊的返回值，那么`Bug`就很难发现了。这对于`optional`返回值来说不是问题。

总结⼀下，异常的设计是针对异常情况的。不要在普通的流程控制中使⽤他们，也不要编写强制其他⼈使⽤异常的`API`。
