# 只在异常条件下使用异常

如果运气不好，你可能会遇到像下面这样的代码：

```java
// Horrible abuse of exceptions. Don't ever do this!
try {
	int i = 0;
	while(true)
		range[i++].climb();

} catch (ArrayIndexOutOfBoundsException e) {

}
```
上述代码做了什么事情呢？从代码中是很难看出来的，单凭这一点，我们就不要这么写代码 （条款67）。这是循环遍历数组中元素的一种非常不好的做法。当这个⽆限循环尝试访问数组边界外的第⼀个元素时，它就会终止，终止的方式则是抛出、捕获并忽略掉` ArrayIndexOutOfBoundsException`。它等价于如下循环遍历数组的标准做法，这种做法对 于任何一个Java程序员来说都是耳熟能详的：

```java
for (Mountain m : range)
	m.climb();
```
那为何还有⼈会选择使⽤基于异常的循环⽅式而非标准方式呢？主要是存在一些误导，那就是使用基于异常的方式可以改进性能，因为`JVM`会检查所有数组访问的边界，⽽正常的循环终⽌测试（被编译期隐藏掉了，不过依旧存在于`for-each`循环中）是冗长且应该避免的。这种说法主要存在3个错误：

 - 由于异常的设计目的是针对于异常情况的，因此`JVM`的实现者们并没有多少动力使其像显式测试那般快。

 - 将代码放到`try-catch`块中会压制`JVM`实现可能会执行的⼀些优化。

 - 循环数组的标准⽅式并不一定会导致冗余的检查。很多`JVM`实现都会对其进⾏优化。 

实际上，基于异常的处理方式要比标准方式慢很多。在我的机器上，对于包含了100个元素的数组来说，前者遍历的速度要比后者慢差不多两倍。

基于异常的循环不仅混淆了代码的用途并降低了它的性能，而且还不能保证正常工作。如果循环中存在`bug`，则对流控制的异常使用会掩盖错误，从而极大地复杂化调试过程。假设循环体中的计算调用了一个方法，该方法对一些不相关的数组执行越界访问。如果使用了合理的循环用法，则该`bug`将null导致一个未捕获的异常，从而导致线程立即终止，并显示完整的堆栈信息。如果使用了错误的基于异常的循环，则与`bug`相关的异常将被捕获并被误解为正常的循环终止。

这个故事的寓意很简单：**异常只在异常的条件下使用，这才符合『异常』这个名字。异常绝不应该用于普通的控制流里**。一般讲，尽可能地使用标准的、易于识别的用法，而不是那些声称可以提供更好性能的过于聪明的技术。即使性能优势是真实存在的，但是随着平台实现一步步改善，这种优势也可能不复存在了。然而，来自过于聪明的技术的细微错误和维护问题肯定会继续存在。

这个原则也适用于`API`设计。**一个设计良好的`API`不会强迫它的客户端在普通的控制流中使用异常**。跟状态相关的方法（只能在某些不可预知的条件下调用）的类通常应该具有一个单独的『测试状态』方法，该方法可以告诉我们现在调用『依赖状态』的方法是否合适。比如，`Iterator`接口有『依赖状态』的方法`next`和对应的『测试状态』方法`hasNext`。在传统`for`循环中，上面提到的2个方法成为遍历一个集合的标准用法。（即便是`for-each`循环，其内部也是使用了`hasNext`方法）：

```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
	...
}
```

如果`Iterator`没有`hasNext`方法，客户将不得不这样做：

```java
// Do not use this hideous code for iteration over a collection!
try {
	Iterator<Foo> i = collection.iterator();
	while(true) {
	Foo foo = i.next();
	...
	}
} catch (NoSuchElementException e) {
    
}
```

这段代码跟文章开头的遍历数组的例子很相似。除了冗余和误导之外，基于异常的循环很可能性能很差，并且可能会掩盖系统中不相关部分的`bug`。

除了提供一个单独的状态测试方法，我们还可以让这个『依赖状态』的方法返回一个空的`Optional`（条款55）或者一个可区分的值，比如`null`，在这个方法无法执行所期望的计算时。

下面有一些指导原则，可以帮助你去选择『测试状态』方法还是一个空的或者可区分的返回值。

如果一个对象将被并发地访问且没有做任何同步，或者因外部诱导的状态转变，你必须使用一个可选的或可区分的返回值，因为从『测试状态』方法再到『依赖状态』方法的调用之间，对象的状态可能在内部改变。如果一个单独的『测试状态』方法将重复『依赖状态』方法的工作，则出于性能考虑，可以使用一个可选的或可区分的返回值。在所有其他条件相同的情况下『测试状态』方法略优于可区分的返回值。它提供了更好的可读性，而且不正确的使用可能更容易发现：如果你忘记调用『测试状态』的方法，那么『依赖状态』的方法将抛出一个异常，这个错误很明显；如果你忘记检查一个可区分的返回值，那么这个错误可能很细微。但`Optional`返回值没有这个问题。

总之，异常是为异常情况设计的。不要将它们用于普通的控制流，也不要编写强迫别人这么做的`API`。
