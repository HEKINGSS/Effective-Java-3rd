# 只在异常条件下使用异常

有一天，如果你不走运，你可能会偶然发现一段类似这样的代码：

```java
// Horrible abuse of exceptions. Don't ever do this!
try {
	int i = 0;
	while(true)
		range[i++].climb();

} catch (ArrayIndexOutOfBoundsException e) {

}
```
这段代码做了什么？for即便读完这个代码，也不是很清楚。这就是不使用它的理由（条款67）。结果证明，使用这段代码来遍历数组，是糟糕的。当程序尝试访问第一个越界的数组元素时，会抛出` ArrayIndexOutOfBoundsException`异常来中断这个死循环，然后捕获并忽略。上面这个程序效果跟循环遍历数组的标准用法是等价的，但是下面的程序对任何一个`Java`程序员都是一目了然的。
```java
for (Mountain m : range)
	m.climb();
```
那么，为什么会有人使用基于异常的循环而不使用tried和true呢？由于`VM`检查所有数组访问的界限，所以编译器隐藏但仍然存在于`for-each`循环中的常规循环终止测试是冗余的，应该避免，因此基于错误的推理来提高性能是一种错误的尝试。
这种推论有三方面是错误的：

 - 因为异常是为异常情况设计的，所以`JVM`实现者几乎没有动力使它们与显式测试一样快。

 - 将代码放在`try-catch`块中会抑制`JVM实`现可能执行的某些优化。

 - 遍历数组的标准做法不一定会导致冗余检查。许多`JVM`实现都将它们优化掉了。

事实上，基于异常的用法比标准用法慢得多。在我的机器上，遍历一个有100个元素的数组，基于异常的用法的速度大约是标准用法的两倍。

基于异常的循环不仅混淆了代码的用途并降低了它的性能，而且还不能保证正常工作。如果循环中存在`bug`，则对流控制的异常使用会掩盖错误，从而极大地复杂化调试过程。假设循环体中的计算调用了一个方法，该方法对一些不相关的数组执行越界访问。如果使用了合理的循环用法，则该`bug`将null导致一个未捕获的异常，从而导致线程立即终止，并显示完整的堆栈信息。如果使用了错误的基于异常的循环，则与`bug`相关的异常将被捕获并被误解为正常的循环终止。

这个故事的寓意很简单：**异常只在异常的条件下使用，这才符合『异常』这个名字。异常绝不应该用于普通的控制流里**。一般讲，尽可能地使用标准的、易于识别的用法，而不是那些声称可以提供更好性能的过于聪明的技术。即使性能优势是真实存在的，但是随着平台实现一步步改善，这种优势也可能不复存在了。然而，来自过于聪明的技术的细微错误和维护问题肯定会继续存在。

这个原则也适用于`API`设计。**一个设计良好的`API`不会强迫它的客户端在普通的控制流中使用异常**。跟状态相关的方法（只能在某些不可预知的条件下调用）的类通常应该具有一个单独的『测试状态』方法，该方法可以告诉我们现在调用『依赖状态』的方法是否合适。比如，`Iterator`接口有『依赖状态』的方法`next`和对应的『测试状态』方法`hasNext`。在传统`for`循环中，上面提到的2个方法成为遍历一个集合的标准用法。（即便是`for-each`循环，其内部也是使用了`hasNext`方法）：

```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
	...
}
```

如果`Iterator`没有`hasNext`方法，客户将不得不这样做：

```java
// Do not use this hideous code for iteration over a collection!
try {
	Iterator<Foo> i = collection.iterator();
	while(true) {
	Foo foo = i.next();
	...
	}
} catch (NoSuchElementException e) {
    
}
```

这段代码跟文章开头的遍历数组的例子很相似。除了冗余和误导之外，基于异常的循环很可能性能很差，并且可能会掩盖系统中不相关部分的`bug`。

除了提供一个单独的状态测试方法，我们还可以让这个『依赖状态』的方法返回一个空的`Optional`（条款55）或者一个可区分的值，比如`null`，在这个方法无法执行所期望的计算时。

下面有一些指导原则，可以帮助你去选择『测试状态』方法还是一个空的或者可区分的返回值。

如果一个对象将被并发地访问且没有做任何同步，或者因外部诱导的状态转变，你必须使用一个可选的或可区分的返回值，因为从『测试状态』方法再到『依赖状态』方法的调用之间，对象的状态可能在内部改变。如果一个单独的『测试状态』方法将重复『依赖状态』方法的工作，则出于性能考虑，可以使用一个可选的或可区分的返回值。在所有其他条件相同的情况下『测试状态』方法略优于可区分的返回值。它提供了更好的可读性，而且不正确的使用可能更容易发现：如果你忘记调用『测试状态』的方法，那么『依赖状态』的方法将抛出一个异常，这个错误很明显；如果你忘记检查一个可区分的返回值，那么这个错误可能很细微。但`Optional`返回值没有这个问题。

总之，异常是为异常情况设计的。不要将它们用于普通的控制流，也不要编写强迫别人这么做的`API`。
