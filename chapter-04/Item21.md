#  针对后代来设计接口

在Java 8之前，在不破坏现有实现的情况下向接口添加方法是不可能的。如果你向接口添加新方法，那么现有的实现通常会缺少该方法，然后导致一个编译期异常。在Java 8中，添加了**默认方法**的概念[JLS 9.4]，目的是允许向现有接口添加额外的方法。不过，向既有接口中添加新的方法还是有可能会产生问题和风险的。

默认方法的声明包含一个默认实现，所有实现该接口但没有实现默认方法的类都可以使用这个默认实现。虽然，Java中增加的默认方法使得我们可以向既有接口中添加方法，但却无法保证这些方法能够在所有之前已经存在的实现中正常使用。默认方法被“注入”到现有的实现中，而无需实现者的知情或同意。在Java 8之前，编写这些实现时都默认它们的接口永远不会获得任何新方法。

在Java 8中，核心的集合接口中增加了了很多新的默认方法，这主要是为了简化**lambdas**（第6章）的使用。Java库的默认方法是高质量的通用实现，在大多数情况下，它们工作得很好。不过，**编写一个默认方法，使得每一个实现都保持不变的想法却并非总是可行的**。

比如说，考虑`removeIf`方法，它是在Java 8中被添加到`Collection`接口中的。该方法会在给定的boolean函数（或是断言）返回true时删除对应的元素。其默认实现会通过迭代器来遍历集合，针对每一个元素调用断言，并在断言返回true时通过迭代器的`remove`方法来删除掉元素。其声明类似于如下代码：

```java
// Default method added to the Collection interface in Java 8
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

这是我们所能想到的`removeIf`方法最好的通用实现，不过遗憾的是，它在某些真实的Collection实现中却会失败。比如说，考虑`org.apache.commons.collections4.collection.SynchronizedCollection`。该类来自于**Apache Commons**库，它类似于`java.util`包下静态工厂`Collections.synchronizedCollection`所返回的集合。Apache版本的集合额外又增加了使用客户端所提供的对象来代替集合进行加锁的能力。换句话说，它是个包装类（条款18），在委托给被包装的集合前，所有方法都会对锁对象进行同步。

`Apache SynchronizedCollection`类依旧处于维护之中，不过在本书编写之际，它还没有重写`removeIf`方法。如果将该类用在Java 8中，那么它就会继承`removeIf`的默认实现，而默认实现并不会（实际上也不能）遵守该类的基本承诺：对每个方法调用自动进行同步。默认实现对于同步一无所知，也无法访问到包含着锁对象的字段。如果客户端在调用`SynchronizedCollection`实例的`removeIf`方法时，另外一个线程同时在对其进行并发修改，那就会导致`ConcurrentModificationException`或是其他意外的行为。

为了阻止这种事情在类似的Java平台库实现中发生，比如`Collections.synchronizedCollection`返回的包私有类，JDK维护者们不得不重写默认的`removeIf`方法实现和其他类似的方法，以便在调用默认实现之前执行必要的同步。然而那些早就存在的第三方库的集合实现，就没有这样的机会进行类似的改变以便与接口变更保持一致，但其中一些集合又必须与接口变更保持一致。

**当存在默认方法时，接口的既有实现可能在编译时没有错误或是仅仅存在警告，但却会在运行时失败**。这个问题虽然不是很常见，但也不是孤立的事件。我们已经知道，在Java8中，添加到集合接口中的一些方法就受到了影响，同时也知道有一些既有的实现也受到了影响。

除非有必要，否则应该避免使用默认方法向现有接口添加新方法，在这种情况下，你应该仔细地考虑默认方法实现是否会破坏现有的接口实现。不过，在创建接口时，默认方法对于提供标准的方法实现是非常有价值的，它会简化接口实现的工作量（条款20）。

另外值得注意的一点是，默认方法的设计是不支持从接口中移除方法或是改变既有方法的签名的。接口的这两种变化都会破坏既有的客户端。

寓意很明显。虽然默认方法现在是Java平台的组成部分，**但在设计接口时要非常小心依旧是很重要的事情**。虽然默认方法使得我们可以向既有接口中添加方法，但这么做还是存在很大的风险的。如果接口存在小瑕疵，那么它会对使用者造成长久的影响；如果接口存在严重的问题，那么它一定会导致使用它的API失败。

因此，在发布前测试每个新接口是极其重要的事情。不同的程序员会以不同的方式来实现接口。至少，你应该测试3个不同的实现。编写多个客户端程序来使用每个新接口的实例执行各种任务也是同样重要的。这对确保每个接口都能满足其所有的目标大有裨益。这些步骤会让你在发布前就能够发现接口中的问题，这时修改也是很容易的。**虽然在接口发布后也可以修改其中的问题，不过你不能指望这一点**。