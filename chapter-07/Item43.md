# 优先选择方法引用而非lambdas

相比于匿名类来说，lambdas的主要优势在于其更加简洁。Java提供了一种甚至比lambdas还要简洁的生成函数对象的方式：**方法引用**。如下代码片段维护着一个从任意键到`Integer`值的映射。如果值被解释为键的实例数的总量，那么该程序就是个多重集合实现。该代码片段的功能是如果键不在`map`中，那么就将1关联到该键上；如果键已经位于集合中了，那就增加其所关联的值。

```java
map.merge(key, 1, (count, incr) -> count + incr);
```

注意到上述代码使用了`merge`方法，这是Java 8添加到`Map`接口中的方法。如果给定的键并没有映射存在，那么该方法就会插入给定的值；如果存在映射，那么`merge`方法会将给定的函数应用到当前值与给定的值上，并使用结果来覆盖掉当前值。这个代码片段代表了`merge`方法的一个典型用例。

上述代码已经很棒了，不过还是存在一些样板代码。参数`count`与`incr`并没有加上其他值，他们只不过就是占个位置而已。实际上，这个lambda要做的就是告诉你函数会返回其两个参数的和而已。从Java 8开始，Integer（以及所有其他的数字原生类型的包装类）提供了一个静态方法sum，用来完成相同的事情。我们只需传递一个该方法的引用即可，使用更少的代码得到同样的结果：

```java
map.merge(key, 1, Integer::sum);
```

方法的参数越多，通过方法引用可减少的样板代码就越多。不过在一些lambdas中，你所选择的参数名提供了很有用的文档信息，这使得lambda相比于方法引用来说可读性和可维护性都更好，虽然lambda会更长一些。

方法引用能做的，lambda都可以做（只有一个不太好理解的例外情况，可以看看JLS, 9.9-2）。也就是说，方法引用通常都会得到更简短、更清晰的代码。如果lambda太长或是过于复杂，那么方法引用还会给你这样一个提示：你可以从lambda中将代码抽取为新的方法，并使用该方法的引用来替换掉lambda。你可以为这个方法起个好的名字，并铭记于心。

如果使用IDE编写代码，那么它会在可能的情况下帮助你将lambda替换为方法引用。你应该经常（但并非总是）接受IDE的建议。有时，lambda会比方法引用简洁。这通常发生在方法与lambda位于同一个类的情况下。比如说，考虑如下代码片段，假设代码位于名为`GoshThisClassNameIsHumongous`的类之中：

```java
service.execute(GoshThisClassNameIsHumongous::action);
```

与之等价的lambda如下所示：

```java
service.execute(() -> action());
```

相比于使用lambda的代码片段来说，使用了方法引用的代码片段既没有更短，也没有更加清晰，因此这里优先使用的是lambda。类似地，`Function`接口提供了一个泛型静态工厂方法来返回同一函数：`Function.identity()`。其等价的`lambda：x -> x`要比这个方法更加简短，也更加清晰。

很多方法引用会引用静态方法，不过有4种方法引用并非如此。其中两个是有界和无界的实例方法引用。在有界引用中，接收对象是在方法引用中指定的。在无界引用中，接收对象是在使用函数对象时指定的，这是通过方法所声明的参数前的一个额外参数所指定的。无界引用通常在流管道中用作映射与过滤函数（条款45）。最后，有两种构造方法引用，分别针对类和数组。构造方法引用的作用是作为工厂对象。如下表格总结了所有5种方法引用：

| 方法引用类型   | 示例                   | 对等的lambda                                       |
| -------------- | ---------------------- | -------------------------------------------------- |
| 静态方法       | Integer::pareInt       | str -> Integer.parseInt(str)                       |
| 有界的实例方法 | Instant.now()::isAfter | Instant then = Instant.now(); t -> then.isAfter(t) |
| 无界的实例方法 | String::toLowerCase    | str -> str.toLowerCase()                           |
| 类构造方法     | TreeMap<K,V>::new      | () -> new TreeMap<K,V>                             |
| 数组构造方法   | int[]::new             | len -> new int[len]                                |

总结一下，相比于lambda来说，方法引用更加简洁。当方法引用更加简短且清晰时，那就使用方法引用；当不是这样时，那就使用lambdas。