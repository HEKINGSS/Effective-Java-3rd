# 优先选择原生类型而非包装类型

Java有两部分类型系统，分别是原生类型（如`int`、`double`与`boolean`等）和引用类型（如`String`与`List`等）。每个原生类型都有一个对应的引用类型，称之为包装类型。对应于`int`、`double`与`boolean`的包装类型分别是`Integer`、`Double`与`Boolean`。

正如条款6所述，自动装箱与自动拆箱之间的界限并不是那么明确，不过这并不会消除原生类型与包装类型之间的区别。这两种类型之间存在着真实的差别，意识到使用的是哪一种以及在这两者之间进行谨慎的选择是非常重要的。

原生类型与包装类型之间存在3个主要的差别。首先，原生类型只有值，而包装类型则拥有与其值不同的身份。换句话说，两个包装类型实例可以拥有相同的值，但身份却不同。其次，原生类型只有功能完善的值，而每个包装类型除了对应的原生类型所有的功能性值之外，还有一个非功能性值，即`null`。最后，相比于包装类型来说，原生类型在时间与空间上的效率更高。如果不加注意，那么这3个差别将会使你陷入到麻烦当中。

考虑下面的比较器，它设计的目的是对`Integer`类型的值进行升序排序。回想一下，`Comparator`的`compare`方法返回一个负数、零或正数，具体取决于它的第一个参数是小于、等于还是大于第二个参数。在实践中你不需要编写这个比较器，因为它实现了整数的自然排序，但它是一个有趣的例子：

```java
// Broken comparator - can you spot the flaw?
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

这个比较器看起来可以正常使用，也会通过很多测试。比如说，它可以应用于`Collections.sort`来对百万元素的列表进行正确的排序，无论列表中是否包含重复元素均如此。不过，这个比较器是存在问题的。为了能够看到这一点，只需打印出`naturalOrder.compare(new Integer(42), new Integer(42))`的值即可。这两个`Integer`实例表示相同的值（42），因此表达式的值应该是0才对，但结果却是1，这表示第1个`Integer`值要比第2个大！

那问题出在哪里呢？`naturalOrder`中的第一个测试没问题。计算表达式`i < j`会使得由`i`和`j`所引用的`Integer`实例进行自动拆箱；也就是说，它会提取出其原生值。接着，该表达式会先去检查第一个`int`值是否小于第二个。假如是大于。下一个测试会计算表达式`i==j`，它会对两个对象引用进行身份比较（所谓身份比较，就是比较2个对象是不是一个对象的意思）。如果`i`与`j`引用的是代表相同`int`值的不同`Integer`实例，那么这个比较就会返回`false`，比较器就会错误地返回1，表示第一个`Integer`值大于第二个。**将`==`运算符应用到包装类型上几乎总是错误的。**。

实际上，如果需要一个比较器来描述一个类型的自然顺序，只需调用`Comparator.naturalOrder()`就可以了；如果自己编写比较器，那就应该使用比较器构造方法，或是针对原生类型的`compare`方法（条款14）。也就是说，修复上述比较器问题的方式应该是添加两个局部变量来存储与包装类型`Integer`参数所对应的原生`int`，然后对这些变量执行所有比较。这可以避免错误的身份比较：

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
	int i = iBoxed, j = jBoxed; // Auto-unboxing
	return i < j ? -1 : (i == j ? 0 : 1);
};
```

接下来，看看如下这段程序：

```java
public class Unbelievable {
	static Integer i;
	public static void main(String[] args) {
		if (i == 42)
			System.out.println("Unbelievable");
	}
}
```

它并不会打印出Unbelievable——不过，其行为却非常奇怪。在计算表达式`i == 42`时，程序会抛出`NullPointerException`。问题在于`i`是个`Integer`而非`int`，就像所有非常量对象引用字段一样，其初始值是`null`。在程序计算表达式`i == 42`时，它会将一个`Integer`与一个`int`进行比较。在几乎所有情况下，**当在一个操作中混合了原生类型与包装类型时，包装类型会进行自动拆箱**。如果一个`null`对象引用进行自动拆箱，那就会抛出`NullPointerException`。正如这段程序所展示的那样，这几乎可以发生在任何地方。修复问题的方法也很简单，只需将`i`声明为`int`而非`Integer`就可以了。

最后，看看来自条款6的这段程序：

```java
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
	Long sum = 0L;
	for (long i = 0; i < Integer.MAX_VALUE; i++) {
		sum += i;
	}
	System.out.println(sum);
}
```

该程序的运行速度要比想象中慢很多，因为它不小心将一个局部变量（`sum`）声明成了包装类型`Long`而非原生类型`long`。该程序编译时没有任何错误和警告，不过变量会不断地进行装箱与拆箱操作，这会导致性能上的损失。

在本条款所讨论的所有3个程序中，问题都是一样的：程序员忽略了原生类型与包装类型之间的差别，并受到了惩罚。在前两个程序中，结果是完全失败；在第三个程序中则遇到了性能问题。

那么，何时应该使用包装类型呢？包装类型有几个适合的应用场景。首先是作为集合中的元素、键与值。你无法将原生类型放到集合中，因此需要使用包装类型。这是更加一般的场景中的一个特例。在参数化类型与方法（第5章）中，你必须要使用包装类型作为类型参数，因为Java不允许使用原生类型。比如说，你无法声明类型为`ThreadLocal<int>`的变量，因此需要使用`ThreadLocal<Integer>`。最后，在进行反射方法调用时（条款65），你必须要使用包装类型。

总结一下，在可以选择的情况下，请优先使用原生类型而非包装类型。原生类型更加简单，速度也更快。如果不得不使用包装类型，请多加小心！对于包装类型来说，自动装箱会减少冗长的代码，不过并不会消除风险。在程序使用`==`运算符来比较两个包装类型值时，它会进行一个身份比较（即强一致性比较），这几乎不是你想要的结果。当程序进行涉及到包装与非包装的混合类型计算时，它会进行自动拆箱，当程序进行自动拆箱时，它会抛出`NullPointerException`。最后，程序对原生类型进行装箱时会导致代价高昂且不必要的对象创建。

