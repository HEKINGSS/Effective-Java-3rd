# 审慎地使用本地方法

`Java`程序可以通过`Java Native Interface（JNI）`调用本地方法，本地方法指的是通过本地编程语言如`C`或是`C++`来编写的方法。从历史上来看，本地方法有3个主要的应用场景。他们提供了对特定于平台功能如寄存器的访问；提供了对既有的本地代码库的访问，包括提供了对遗留数据访问的遗留库。最后，本地方法用于以本地语言编写应用中性能关键的部分以改进性能。

使用本地方法访问特定于平台的功能是合情合理的，不过极少需要这么做：随着`Java`平台的 不断成熟，它提供了对之前只有在宿主平台才有的很多特性的访问能力。比如说，`Java 9`新增的进程`API`就提供了对`OS`进程的访问能力。当`Java`中不存在相应的库时，通过本地方法来 使用本地库也是合理的。

**一般不建议通过本地方法来改进性能。**在`Java`的早期版本中（`Java 3`之前），这么做常常是必要的，不过从那以后，`JVM`的运行速度快了很多。对于大多数任务来说，`Java`也可以获得与本地方法相当的性能。比如说，在`java.math`添加到`1.1`版时，`BigInteger`依赖于使用`C`所编写的速度更快的多精度算法库。在`Java 3`中，`BigInteger`使用`Java`进行了重新实现，并且进行了细致的调优，使得其运行速度要比之前的本地实现还要快。

遗憾的是，从那儿以后，`BigInteger`基本就没什么变化了了，只不过在`Java 8`中实现了对于大数乘法更快的操作。这期间，工作主要放在了本地库上，值得关注的就是`GNU Multiple Precision`算法库（GMP）。需要真正高性能多精度算法的`Java`程序员可以通过本地方法使用`GMP` [Blum14]。

使用本地方法存在严重的缺陷。由于本地语言是不安全的（条款50），因此使用本地方法的应用可能会遇到内存错误。由因为本地语言要比`Java`更加依赖于平台，因此使用本地方法的程序的可移植性会更差。此外，调试难度也变得更大了。一不小心，本地方法就会降低性能， 因为垃圾收集器无法自动，甚至无法追踪本地内存的使用情况（条款8），而且进出本地代码也是有成本的。最后，本地方法需要『胶水代码』，这种代码难以阅读，写起来也很啰嗦。

总结一下，在使用本地方法前请三思。很少会出现需要通过本地方法来改进性能的情况。如果不得不通过本地方法来访问底层资源或是本地库，那就请尽量少地使用，并且做充分的测试。本地代码中的一个`Bug`会导致整个应用崩溃。