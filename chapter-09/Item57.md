# 最小化局部变量的作用域

从本质上来说，本条款类似于条款15：最小化类与成员的可访问性。通过最小化局部变量的作用域，我们可以增加代码的可读性与可维护性，同时还会降低出错的可能性。

诸如C语言之类的老式编程语言会强制要求将局部变量声明在块的头部，一些程序员就继续遵循着这个习惯。不过，这是个值得打破的习惯。友情提示一下，Java可以在语句合法的任何地方声明变量（从C99开始，C语言也可以这样做了）。

用于最小化局部变量作用域的最为强大的技术就是在首次需要时再进行声明。如果变量在使用前声明，那就会有些杂乱——对于那些想要搞清楚程序用途的读者来说，这会分散他们的注意力。等到使用变量时，读者可能就记不得变量的类型或是初始值了。

过早声明局部变量不仅会导致其作用域过早开始，还会造成过晚结束的后果。局部变量的作用域从其声明之处开始，一直延续到外层块结束为止。如果变量声明在其所需要使用的块的外部，那么当程序退出这个块时，它还依旧可见。如果不小心在应该使用变量的区域的前面或者后面用到了这个变量，那后果就是灾难性的了。

**几乎每个局部变量声明都应该包含一个初始化器**。如果没有足够的信息来初始化变量，那就应该将声明推迟到信息足够之时。该原则的一个例外情况是`try-catch`语句。如果变量被初始化为一个表达式，而该表达式的计算可能会抛出一个检查异常，那就应该在`try`块中初始化该变量（除非外层方法可以传播该异常）。如果值是在`try`块外使用的，那么它就需要在`try`块之前进行声明，而在这里进行声明就是所谓的『不太聪明的初始化』。比如说，请参阅第283页。

循环展现出了最小化变量作用域的一种特殊机会。`for`循环（无论是传统的还是`for-each`形式）可以声明循环变量，并将其作用域限制为所需的精确区域（该区域包含了了循环体以及`for`关键字与体之间的圆括号中的代码）。因此，如果循环变量的内容在循环终止后就用不上了，那么相比于`while`循环来说，请优先选择`for`循环。

比如说，下面是迭代集合的一种推荐做法（条款58）：

```java
// Preferred idiom for iterating over a collection or array
for (Element e : c) {
... // Do Something with e
}
```

如果需要访问迭代器，比如说调用其`remove`方法，那么推荐的做法是使用传统的`for`循环来代替`for-each`循环：

```java
// Idiom for iterating when you need the iterator
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
	Element e = i.next();
	... // Do something with e and i
}
```

要想理解为何这些`for`循环要优于`while`循环，请考虑如下代码片段，它包含了两个`while`循环和一个`Bug`：

```java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
	doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) { // BUG!
	doSomethingElse(i2.next());
}
```

第二个循环包含了一个复制粘贴错误：它初始化了一个新的循环变量`i2`，不过使用的却是老的变量`i`，遗憾的是，变量`i`依旧处于作用域当中。代码可以编译通过且没有错误，运行时也不会抛出异常，但结果却不对。第二个循环会立刻终止而不会对`c2`进行迭代，这让我们错误地认为`c2`是空的。因为程序会无声地出错，所以很长一段时间内都无法检测到该错误。

如果类似的复制粘贴错误与`for`循环（`for-each`或是传统的`for`循环）搭配使用，那么代码将无法编译通过。第一个循环中的元素（或是迭代器）变量并不处于第二个循环的作用域中。如下代码展示了使用传统`for`循环的样子：

```java
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
	Element e = i.next();
	... // Do something with e and i
}
...
    
// Compile-time error - cannot find symbol i
for (Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
	Element e2 = i2.next();
	... // Do something with e2 and i2
}
```

此外，如果使用`for`循环，那么出现复制粘贴错误的可能性将会大大降低，因为没必要在两个作用域中使用不同的变量名。循环是完全独立的，因此重用元素（或是迭代器）变量名是没有任何问题的。实际上，人们也经常会这么做。相比于`while`循环来说，`for`循环还有另外一个好处：它更加简练，这增强了可读性。

如下是另一种常见的用于最小化局部变量作用域的循环写法：

```java
for (int i = 0, n = expensiveComputation(); i < n; i++) {
	... // Do something with i;
}
```

关于这种惯用法值得注意的重要事项在于它有两个循环变量`i`与`n`，他们都有精确且正确的作用域。第二个变量`n`用于存储第一个变量的限度，这就避免了每次迭代时进行冗余计算的成本。作为一条原则，如果循环测试涉及到方法调用，而该调用在每次迭代时都会返回相同的结果，那么你就应该使用这种用法。

最小化局部变量作用域的最后一项技术是保持方法尽可能小且聚焦。如果将两个活动放到相同的方法中，那么与一个活动相关的局部变量就可能处于执行另外一个活动的代码的作用域中。为了防止这种情况的发生，只需将方法分成两个即可：每个方法只针对一个活动。