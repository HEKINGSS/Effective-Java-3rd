# 通过接口来引用对象

条款51指出，我们应该使用接口而非类来作为参数类型。更为一般的，我们应该优先使用接口而非类来引用对象。**如果存在恰当的接口类型，那么参数、返回值、变量与字段都应该声明为接口类型**。唯一需要引用对象类的地方就是使用构造方法来创建的时候。具体一些，考虑一下`LinkedHashSet`这个例子，它是`Set`接口的一个实现。请像下面这样来做：

```java
// Good - uses interface as type
Set<Son> sonSet = new LinkedHashSet<>();
```

不要这样做：

```java
// Bad - uses class as type!
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

**如果习惯于使用接口作为类型，那么程序将会变得更加灵活。**。如果想要切换实现，那就只需在构造方法中修改类名（或是使用不同的静态工厂）即可。比如说，我们可以将第1个声明修改成下面这样：

```java
Set<Son> sonSet = new HashSet<>();
```

其他代码依旧可以正常使用。周围代码感知不到老的实现类型，因此它对修改并不知情。这里有个警告要说明一下：如果原来的实现提供了一些接口通用契约所不要求的一些特殊功能，同时代码又依赖于这个功能，那么新的实现也需要实现相同的功能。比如说，如果第1个声明周围的代码依赖于`LinkedHashSet`的排序策略，那么在这种场景下将`LinkedHashSet`替换为`HashSet`就是不对的了，因为`HashSet`并不保证迭代顺序。

那么，为何需要改变实现类型呢？由于相比于最初的实现来说，第2个实现提供了更好的性能，或是提供了最初实现所缺乏的功能。比如说，假设一个字段包含了`HashMap`实例。将其修改为`EnumMap`会提供更好的性能，并且还可以提供与键的自然顺序相一致的迭代顺序；不过，如果键类型是个枚举类型的话，那就只能使用`EnumMap`了。将`HashMap`修改为`LinkedHashMap`将会提供可预测的迭代顺序，同时又会提供与`HashMap`相当的性能，而且并不会对键类型有任何特殊的需求。

你可能觉得使用实现类型来声明变量也是没问题的，因为可以同时修改声明类型与实现类型，不过这种修改却无法保证程序能够编译通过。如果客户端代码使用了最初的声明类型中的方法，其替换者并没有这些方法，或是如果客户端代码将实例传递给了需要之前声明类型的方法中，那么在修改后，代码将无法编译通过。使用接口类型来声明变量可以避免这些问题。

**如果没有恰当的接口存在，那么通过类来引用对象是完全可以的**。比如说，考虑值类（`value classes`），如`String`和`BigInteger`。值类很少会有多种实现。他们通常是`final`的，很少存在对应的接口。使用这种值类作为参数、变量、字段或是返回类型就是完全恰当的。

没有恰当的接口类型存在的第2种情形是对象从属于某个框架，而框架的基础类型是类而非接口。如果对象归属于这种基于类的框架，那么通过相关的基类来引用它就是合理的，这里的基类通常是抽象的，而不是通过实现类来引用。很多`java.io`类如`OutputStream`都属于这种情况

没有恰当的接口类型存在的最后一种情况是类实现了接口，但又提供了接口中不存在的额外方法；比如说，`  PriorityQueue `有一个`comparator`方法，而这个方法并在`Queue`接口中。只有当程序依赖于额外的方法时才应该使用类来引用其实例，不过这种情况非常少见。

情况并非只有以上3种，这里只不过是给出通过类来引用对象是比较恰当的几种情况而已。实际上，给定对象是否有一个恰当的接口是很明显的。如果有，那么使用接口来引用对象，程序就会更加灵活和方便。如果没有恰当的接口，那么就请使用类层次体系中提供了所需功能的那个最不具体的类。